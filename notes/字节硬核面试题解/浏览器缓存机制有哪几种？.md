# 浏览器缓存机制有哪几种？

## 一、请求资源的缓存

根据缓存机制共分为**三**种类型：

1. 强缓存策略：根据请求头中的 expires 和 cache-control 判断是否命中，主要分三种情况：

    1. 第一次请求资源，不存在缓存结果和缓存标识，直接从服务器获取资源；
    2. 存在缓存结果和缓存标识，但是过期失效，使用**协商缓存**；
    3. 存在缓存结果和缓存标识，且未过期有效，则直接从缓存中获取结果返回；
    4. 控制强缓存的字段分别是 Expires 和 Cache-control，其中 Cache-control 的优先级要比 Expires 高；
    5. Expires 用执行资源到期时间，通常是 `Expires = max-age + 请求时间（受 last-modified 影响）`，*需要注意的是，Expires 是 HTTP/1 的产物，受限于本地时间，修改本地时间可能会导致缓存失效*；
    6. Cache-control: 是 HTTP/1.1 控制缓存的重要标识，其取值主要为：
        1. `no-store`：不使用缓存；
        2. `no-cache`：在获取缓存的资源之前，先请求服务器验证资源是否和服务器端资源一致；
        3. `public`：所有内容都将被缓存（客户端、代理服务器都会被缓存）；
        4. `private`：所有内容只有客户端可以缓存；
        5. `max-age=<seconds>`：缓存内容将在 seconds 秒之后失效。

2. 协商缓存：如果未命中强缓存策略，浏览器会发送请求，根据请求头的 last-modifed 和 etag 判断是否命中协商缓存；

    1. 携带缓存标识向服务器发送请求，有服务器决定是否使用缓存；
    2. 协商缓存生效，返回 304 和 `Not Modified`；
    3. 协商缓存失效，返回 200 和请求结果；
    4. 浏览器首先发送一个请求，服务器会在响应头上设置返回请求的资源的上次更新时间，就是 last-modified，浏览器会缓存下这个时间；
    5. 浏览器在下次请求中，在请求头中设置了 If-modified-since: [last-modified] ，服务器根据浏览器发送的 last-modified 与服务器的 last-modified 时间进行对比，如果一致则返回空响应，减少请求的消耗。如果不一致，则返回新的资源和响应；
    6. 虽然 last-modified 保存的是绝对时间，但是仍然有误差，为了解决误差提出了 etag 和 if-none-match ；
    7. etag 和 if-none-match 和 last-modified 的原理相同：第一次请求时，服务器会在响应头上的设置 etag 的值（版本号、时间戳的哈希值等等）然后发给浏览器，浏览器收到 etag 的值缓存在 If-none-match 中，在以后的资源请求中，浏览器想服务器发送 if-none-match: [etag 值]，服务器通过对比浏览器的 if-none-match 和自己的 etag 的值判断资源是否需要重新发送。

3. 如果未命中协商缓存策略，浏览器会直接从服务器获取资源。


## 二、数据缓存

