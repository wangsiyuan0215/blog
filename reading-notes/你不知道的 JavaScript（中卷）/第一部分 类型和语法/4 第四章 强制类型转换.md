## 4.1 值类型转换

JavaScript 中的强制转换总是返回基本类型值，如字符串、数字和布尔值，不会返回对象和函数。

## 4.2 抽象值操作

#### 4.2.1 ToString

JSON 字符串化并非严格意义上的强制类型转换，对于简单值来说，JSON 字符串化与 `toString()` 的效果基本相同，对于复杂的值 JSON 字符串化要求值必须是**安全的**，如 `undefined`、`function`、`symbol` 以及循环对象引用均为不安全的 JSON 值。

如果一个对象中定义了 `toJSON()` 方法，JSON 字符串化时会优先调用该方法，然后用它的返回值来进行序列化。

应该说，toJSON 应该**返回一个能够被字符串化的安全的 JSON 值**，而不是**返回一个 JSON 字符串**。

```javascript
var a = {
  val: [1, 2, 3],
  toJSON: function() {
    // 这是我们想要的结果
    return this.val.slice(1);
    
    // 这不是我们想要的结果
    // return "[" + this.val.slice(1).join() + "]";
  }
};
```

`JSON.stringify()` 可以传递另外一个可选参数，他可以是数组或者是函数。

* 如果是数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外的属性会被忽略；
* 如果参数是函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个属性，返回 `undefined` ，否则返回指定的值。

#### 4.2.2 ToNumber

`true` 转换为 1，`false` 转换为 0，`undefined` 转换为 `NaN`，`null` 转换为 0。

对象（包括数组）会首先被转换为相应的基本类型值：

* ToPrimitive 会首先检查该值是否有 `valueOf()` 方法，如果有且返回基本类型值，那么就使用该值进行强制类型转换。
* 如果没有则使用 `toString()` 方法的返回值来进行强制类型转换;
* 如果 `valueOf()` 和 `toString()` 均不返回基本类型值，则会产生 `TypeError` 错误。

需要注意的是，`Object.create(null)` 创建的对象 `[[Prototype]]` 属性为 `null`，并且没有 `valueOf()` 和 `toString()` 方法，因此无法进行强制类型转换。

## 4.3 显示强制类型转换

日期显示转换为数字：

```javascript
var timestamp = +new Date();
```

#### **位运算符**

之前说过运算符会强制操作数使用 32 位格式，这是由于 `ToInt32` 来实现的，`ToInt32` 首先执行 `ToNumber` 强制类型转换，然后再执行 `ToInt32`。

因此，对于 | 运算符来说，下列 4 个特殊数字无法以 32 位格式呈现：

* 0 | -0
* 0 | NaN
* 0 | Infinity
* 0 | -Infinity

以上四个转换结果均为 0。

通过对于 ~(-1) 取反的结果是 0，而不是 -0，是由于它是字位操作，而非是数学运算，如下：

```javascript
~(-1) => -(-1 + 1) => -0 => 0
```

一些开发人员使用 `~~` 来截除数字值的小数部分，认为和 `Math.floor()` 效果一样，实际上并不是这样。

`~~` 中的第一个 `~` 执行 `ToInt32` 并反转字位，然后第二个 `~` 在进行一次字位反转，即将所有的字位反转回原值，最后得到的仍然是 `ToInt32` 的结果。

使用 `~~` 需要注意的是，它只适用于 32 为数字，同时对于负数的处理，与 `Math.floor()` 不同：

```javascript
Math.floor(-49.6); 	// -50
~~(-49.6); 					// -49
```

如果能确定数字的位数是小于等于 32 位的话，使用 `|` 位运算符与使用 `~~` 相同，但是 `|` 位运算符更简洁。

但是出于运算符优先级考虑，更倾向于 `~~`，原因如下：

```javascript
~~1E20 / 10; 			// 166199296
1E20 | 0 / 10;		// 1661992960 （先执行 0 / 10 = 0，然后 1E20 | 0 仅做了转换）
(1E20 | 0) / 10; 	// 166199296
```

#### `ParseInt`

**ES5 之前的 parseInt 有个 bug，就是如果没有第二个参数来制定转换的基数，那么会根据字符串第一个字符来自行决定基数，如果第一个字符是 x 或 X 的话，会认为是*十六进制*，如果是 0 则会转换为*八进制*。**

`parseInt` 会先将**第一个参数强制类型转换为字符串**，再进行解析。比如 `parseInt(1/0, 19)` 中的 `1/0` 的结果是 `Infinity`，首字符是 `I`，而 parseInt 的第二个参数是 19，基数 19 的有效数字范围是 0 - 9 和 a - i（不区分大小写），而 `I` 在 19 进制的基数是 18。

还有一些特殊的例子：

```javascript
parseInt(0.000008)		// 0 ('0' 来自于 '0.000008')
parseInt(0.0000008)		// 8 ('8' 来自于 '8e-7')
parseInt(false, 16)		// 250 ('fa' 来自于 'false' 的 16 进制)
parseInt(parseInt, 16)	// 15 （'f' 来自于 'function...')
```

#### 字符串和数字之间的隐式强制类型转换

`valueOf()` 操作无法得到简单基本类型值，于是转而调用 `toString()`。

```javascript
var a = [1, 2];
var b = [3, 4];

a + b; // '1,23,4'
```

将字符串转换为数字的方式有：

```javascript
var a = '3.14';
var b = a - 0;

b; 	// 3.14
```

`-` 是数字减法运算符，因此 `a - 0` 会将 `a` 强制转换为数字。因此也可以使用 `a * 1` 或 `a / 1` 将字符串转为数字。

#### `||` 和 `&&` 

对于 `||` 来说，如果条件判断结果为 true，就返回第一个操作数的值，如果为 false 则返回第二个操作数的值；

`&&` 则正好相反，如果条件判断结果为 true 就会返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

#### 符号的强制类型转换

ES6 引入了符号类型，它的强制类型转换有坑。需要知道的是，ES6 允许从符号到字符串的**显示**强制类型转换，然而隐式强制类型转换则会产生错误。

```javascript
var s1 = Symbol('cool');
String(s1);		// Symbol('cool')

var s2 = Symbol('not cool');
s2 + ''; 		// TypeError
```

#### 宽松相等和严格相等

`==` 允许在相等比较中进行强制类型转换，`===` 不允许。

#### 抽象相等

需要记住的是：

* `NaN` 不自等 `NaN === NaN // false`；
* `+0` 与 `-0` 相等 `+0 == -0 // true`；

##### 字符串与数字的相等比较：

ES5 规范中这样定义：

1. 如果 `Type(x)` 是数字，`Type(y)` 是字符串，则返回 `x == toNumber(y)` 的结果；
2. 如果 `Type(x)` 是字符串，`Type(x)` 是数字，则返回 `toNumber(x) == y` 的结果；
3. `''` 、`'\n'` 或者 `' '` (或者其他空格的组合) 都会被转换为 0，因此 `0 == '\n'` 的结果为 true。

##### *其他类型*与布尔类型的相等比较：

ES5 规范中这样定义：

1. 如果 `Type(x)` 是布尔类型，则返回 `toNumber(x) == y` 的结果；
2. 如果 `Type(y)` 是布尔类型，则返回 `x == toNumber(y)` 的结果。

从上述两章里来看，相等比较的隐式转换中，布尔类型拥有最先被转换的特点，也就说不论相等比较的另一端是什么类型，都要先将布尔类型转换为数字。

##### `null` 和 `undefined` 之间的相等比较

ES5 中规范这样定义：

1. 如果 x 为 `null`，y 为 `undefined` ，则结果为 `true`；
2. 如果 x 为 `undefined`，y 为 `null` ，则结果为 `true`；

##### *对象和非对象*之间的相等比较

ES5 规范中这样定义：

1. 如果 `Type(x)` 是字符串或者是数字，`Type(y)` 是对象，则返回 `x == toPrimitive(y)` 的结果；
2. 如果 `Type(x)` 是对象，`Type(y)` 是字符串或者是数字，则返回 `toPrimitive(x) == y` 的结果；

如果存在布尔类型，则先将布尔类型转换为数字后，再执行上述规则。

#### 比较少见的情况

```javascript
Number.prototype.valueOf = function() {
  return 3;
}

new Number(2) == 3; 		// true
```

`Number(2)` 涉及的是 `toPrimitive` 强制类型转换，因此会调用 `valueOf`。

还有一些极端的情况：

```javascript
[] == ![]		// true
```

这是因为首先对 `![]` 进行强制类型转换为 false，而布尔类型 false 会被先转换为数字 0，之后对 `[]` 进行 `toPrimitive` 转换，调用 `valueOf` 返回 `''`，然后 `''` 也会转换为数字 0，因此最终相等比较结果为 true。

#### 安全运用隐式强制类型转换

以下两个原则可以让我们有效地避免出错：

1. 如果两边的值中有 true 或者 false，千万不要用 `==`；
2. 如果两边的值有 `[]`、`''` 或 `0` ，尽量不要用 `==`。

#### 抽象关系比较（对象与对象的比较）

如果相等比较的双方均为字符串，则按照字母的顺序进行比较：

```javascript
var a = ['42'];
var b = ['043'];

a < b;		// false => '42' < '043'
```

参考以下情况：

```javascript
var a = { b: 42 };
var b = { b: 43 };

a >= b;		// true => b <= a => !(b > a)
b >= a;		// true => a <= b => !(b < a)
```

为什么？

这是因为根据规范 `a <= b` 被处理为 `b < a` ，然后将结果反转，因为 `b < a` 的结果（根据字母的顺序，二者都是 `[object Object]`）是 false，反转之后则为 true。

相等比较有严格相等，但是关系比较却没有"严格关系比较"。因此为了避免在关系比较中发生隐式类型转换，需要确保关系比较的双方为相同的类型。







