## 4.1 值类型转换

JavaScript 中的强制转换总是返回基本类型值，如字符串、数字和布尔值，不会返回对象和函数。

## 4.2 抽象值操作

#### 4.2.1 ToString

JSON 字符串化并非严格意义上的强制类型转换，对于简单值来说，JSON 字符串化与 `toString()` 的效果基本相同，对于复杂的值 JSON 字符串化要求值必须是**安全的**，如 `undefined`、`function`、`symbol` 以及循环对象引用均为不安全的 JSON 值。

如果一个对象中定义了 `toJSON()` 方法，JSON 字符串化时会优先调用该方法，然后用它的返回值来进行序列化。

应该说，toJSON 应该**返回一个能够被字符串化的安全的 JSON 值**，而不是**返回一个 JSON 字符串**。

```javascript
var a = {
  val: [1, 2, 3],
  toJSON: function() {
    // 这是我们想要的结果
    return this.val.slice(1);
    
    // 这不是我们想要的结果
    // return "[" + this.val.slice(1).join() + "]";
  }
};
```

`JSON.stringify()` 可以传递另外一个可选参数，他可以是数组或者是函数。

* 如果是数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外的属性会被忽略；
* 如果参数是函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个属性，返回 `undefined` ，否则返回指定的值。

#### 4.2.2 ToNumber

`true` 转换为 1，`false` 转换为 0，`undefined` 转换为 `NaN`，`null` 转换为 0。

对象（包括数组）会首先被转换为相应的基本类型值：

* ToPrimitive 会首先检查该值是否有 `valueOf()` 方法，如果有且返回基本类型值，那么就使用该值进行强制类型转换。
* 如果没有则使用 `toString()` 方法的返回值来进行强制类型转换;
* 如果 `valueOf()` 和 `toString()` 均不返回基本类型值，则会产生 `TypeError` 错误。

需要注意的是，`Object.create(null)` 创建的对象 `[[Prototype]]` 属性为 `null`，并且没有 `valueOf()` 和 `toString()` 方法，因此无法进行强制类型转换。

## 4.3 显示强制类型转换

日期显示转换为数字：

```javascript
var timestamp = +new Date();
```

#### **位运算符**

之前说过运算符会强制操作数使用 32 位格式，这是由于 `ToInt32` 来实现的，`ToInt32` 首先执行 `ToNumber` 强制类型转换，然后再执行 `ToInt32`。

因此，对于 | 运算符来说，下列 4 个特殊数字无法以 32 位格式呈现：

* 0 | -0
* 0 | NaN
* 0 | Infinity
* 0 | -Infinity

以上四个转换结果均为 0。

通过对于 ~(-1) 取反的结果是 0，而不是 -0，是由于它是字位操作，而非是数学运算，如下：

```javascript
~(-1) => -(-1 + 1) => -0 => 0
```

一些开发人员使用 `~~` 来截除数字值的小数部分，认为和 `Math.floor()` 效果一样，实际上并不是这样。

`~~` 中的第一个 `~` 执行 `ToInt32` 并反转字位，然后第二个 `~` 在进行一次字位反转，即将所有的字位反转回原值，最后得到的仍然是 `ToInt32` 的结果。

使用 `~~` 需要注意的是，它只适用于 32 为数字，同时对于负数的处理，与 `Math.floor()` 不同：

```javascript
Math.floor(-49.6); 	// -50
~~(-49.6); 					// -49
```

如果能确定数字的位数是小于等于 32 位的话，使用 `|` 位运算符与使用 `~~` 相同，但是 `|` 位运算符更简洁。

但是出于运算符优先级考虑，更倾向于 `~~`，原因如下：

```javascript
~~1E20 / 10; 			// 166199296
1E20 | 0 / 10;		// 1661992960 （先执行 0 / 10 = 0，然后 1E20 | 0 仅做了转换）
(1E20 | 0) / 10; 	// 166199296
```

#### `ParseInt`

**ES5 之前的 parseInt 有个 bug，就是如果没有第二个参数来制定转换的基数，那么会根据字符串第一个字符来自行决定基数，如果第一个字符是 x 或 X 的话，会认为是*十六进制*，如果是 0 则会转换为*八进制*。**

`parseInt` 会先将**第一个参数强制类型转换为字符串**，再进行解析。比如 `parseInt(1/0, 19)` 中的 `1/0` 的结果是 `Infinity`，首字符是 `I`，而 parseInt 的第二个参数是 19，基数 19 的有效数字范围是 0 - 9 和 a - i（不区分大小写），而 `I` 在 19 进制的基数是 18。

还有一些特殊的例子：

```
parseInt(0.000008)		// 0 ('0' 来自于 '0.000008')
```



