## 问：如何测试某个运算的速度（执行时间）？

请先看反面教材：

```javascript
const start = Date.now();

// 一些运算

const end = Date.now();

console.log('Duration:', (end -start));
```

以上方案绝大多数的 JavaScript 开发者都会首先想到，这种方案有很多错误。

* 如果报告的时间为 0 ，那么我们认为它的执行时间小于 1ms。但是这并不准确，有些平台的精度并没有达到 1 ms，而是以更大的间隔更新定时器。比如早期的 Windows 版本的精度只有 15 ms，那么这就意味着这个运算至少运算 15 ms 以上才不会报告 0；
* 以上得到的结果仅仅只能代表这一次的运算速度，因为它并不能总是以这样的速算运行（受引擎和系统的影响）。
* 测试所得到的运算时长并不是精确的，仅仅是估算，因为也需要考虑到 `start` 和 `end` 获取时间戳的延误；
* 未知的环境过度优化。针对这次计算运算时间的测试，无法保证 JavaScript 引擎不会进行优化。但在更真实的程序中无法进行这种优化，那么这个运算就比在测试时跑得慢。

## 尾调用优化（TCO)

简单地说，尾调用就是一个出现在另一个函数“结尾”处的函数调用，除此之外，不作任何其他事情（除了返回结果值）。

```javascript
function foo(x) {
  return x;
}

function bar(y) {
  return foo(y + 1);		// 尾调用
}

function baz() {
  return 1 + bar(40);		// 非尾调用
}

baz()
```

 `foo(y + 1)` 是 `bar(...)` 中的尾调用，是由于在 `foo(...)` 完成后，`bar(...)` 也完成了，只需要返回 `foo(...)` 的结果。

而 `bar(40)` 不是尾调用，因为在它完成后，它的结果需要加 1 才能由 `baz()` 返回。

调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧。上述代码中，引擎会为 `foo(y + 1)`, `bar(40)`,`baz()` 保留一个栈帧。

如果引擎支持 TCO，就能够意识到 `foo(y + 1)` 是尾调用，这意味着 `bar(...)` 基本已经完成，那么在调用 `foo(...)` 时，就不需要创建一个新的栈帧，而是重用已有的 `bar(...)` 的栈帧。**这样不仅速度快，而且节省内存**。

尾调用优化在处理递归时，解决了大问题。有了 TCO，引擎可以引用同一个栈帧执行所有这类调用！

在处理递归函数时，如果没有 TCO，引擎需要实现一个随意的限制来界定递归的深度，达到了就停止，防止内存耗尽。有了 TCO，尾调用的递归函数本质上可以任意运行，因为再也不需要使用额外的内存了，只是递归开始时被分配的内存就行。

当然，这一切的前提是需要写出尾调用的递归函数。