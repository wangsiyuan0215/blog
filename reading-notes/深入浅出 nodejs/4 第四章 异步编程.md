## 第四章 异步编程

node 与 浏览器环境均是事件驱动；

### 4.1 函数式编程

> 高阶函数：把函数当做参数或者是将函数作为返回值的函数；

node 事件的处理方式正是基于高阶函数的特性来完成的；

> 偏函数：创建一个调用另外一个部分——参数或者变量已经预置的函数——的函数；

柯里化是典型例子，可以缓存参数；

### 4.2 异步编程的优点

“最大特性莫过于基于事件驱动的非阻塞 I/O 模型”；

不论是计算密集型，还是 I/O 密集型，只要计算不影响的异步 I/O 的调度，那就不构成问题；

建议对 CPU 的耗用不要超过 10 ms，或者将大量的计算分解为诸多的小型计算，通过 setImmediate() 进行调度；

#### 1. 异步编程的难点

1. 异常处理，对异步方法进行 `try/catch` 操作只能捕获当次事件循环（一个 Tick）内的异常；
2. 函数嵌套过深（回到地狱），这是异步编程的典型问题；
3. 阻塞代码；
4. 多线程编程，`child_process` 是基础 API，`cluster` 模块是更深层次的应用；
5. 异步转同步；

### 4.3 异步编程解决方案：

主要解决方案有如下 3 中：

1. 事件发布/订阅模式；
2. Promise / Deffered 模式；
3. 流程控制库；

#### 1. 事件发布/订阅模式

发布/订阅模式本身并无同步和异步调用的问题，但是 node 中，emit() 调用多半是伴随着事件循环而异步触发的，因此事件发布/订阅广泛应用于异步编程；

1. 利用事件队列解决雪崩问题

雪崩问题：高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度；

利用 events 的 once() 方法请所有的请求的回调压入事件队列中，利用其执行一次就会被监视器移除的特点，保证没一个回调都会被执行一次；