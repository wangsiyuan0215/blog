## 第一章 作用域是什么

#### JavaScript 的代码在执行之前（编译）需要经历三个步骤：

##### 1. 分词/词法分析

将字符组成的字符串分解成有意义的代码块，这些代码块被称为**词法单元**；

`编写的代码的字符串 -> 词法单元`

##### 2. 解析/语法分析

将词法单元流（数组）转为一个有元素逐级嵌套所组成的代表了程序语法结构的树；

`词法单元流 -> 抽象语法树（AST）`

##### 3. 代码生成；

将 AST 抽象语法树转换为可执行的过程被称为代码生成；

`AST -> 可执行的过程（可以理解为真正可以执行的“代码”）`

#### 而在整个 JavaScript 代码的编译和执行的过程中，共有三个核心成员参与其中，它们分别是：

##### 1. 引擎

贯穿 JS 程序编译和执行过程的老大哥；

##### 2. 编译器

主要负责语法分析和代码生成；

##### 3. 作用域

主要负责词法分析，由此可以知道 JS 的作用域是静态作用域，也成为词法作用域，并且是在代码编写时确定下来的；

仅针对 `var a = 2;` 这段代码来说，实际上是作用域确定变量 `a` 的所在作用域，然后编译器会在当前作用域中声明一个变量，然后运行时引擎会在作用域中查找当前变量，如果找到了就会对它赋值；

_那么如何确定变量 `a` 所在的作用域呢？_

#### RHS 和 LHS

主要针对的是：赋值操作的左右两侧的查询规则；

当变量出现在赋值操作的左侧的时候，使用 LHS 查询，出现在右侧的时候使用 RHS 查询，需要注意的是，LHS 和 RHS 唯一的共同点就是二者都是在当前作用域下开始查找；

OK，到这里可以试着翻译一下，出现在赋值操作右侧的变量，实际上只是查询变量的值，而出现左侧的变量查找的规则要复杂一些；

需要注意的是，函数**执行时**参数的传递是 LHS 查询，意味着将参数的值 `=` （赋值给）形参；

```JavaScript
function foo(a) {
    console.log(a); // a -> RHS
}

foo(2) // foo -> RHS, foo( a = 2 ) -> LHS
```

区分 LHS 和 RHS 的本质就是判断是否有“赋值”行为；

同时在本书中还提及到，函数声明并非是基于 LHS 查询和赋值的形式；

如果在一个作用域（A）内通过 LHS 或 RHS 无法找到某一个变量时，会向上一层作用域（B）查找，以此类推，直到找到或者找不到报错为止；

**区分 LHS 和 RHS 是一件很重要的事情，因为变量还没有声明的情况下，这两种查询的行为是不一样的；**

如果 RHS 查询在**所有**作用域中查找不到所需要的变量，引擎则会跑出 `ReferenceError` 异常；

如果 LHS 查询所有作用域之后查不到所需要的变量，会在*全局作用域*中创建当前变量并将其返回给引擎（在非严格模式下，严格模式下会报错）；
