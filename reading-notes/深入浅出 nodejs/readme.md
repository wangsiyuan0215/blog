# 《深入浅出 NodeJs》（读书笔记初稿）

高性能 Web 服务器：事件驱动、非阻塞 I/O;

单线程、单进程

单线程的缺点：

1. 无法利用多核 CPU；
2. 错误会引起整个应用退出，应用的健壮性值得考验；
3. 大量计算占用 CPU 导致无法继续调用异步 I/O；

Web Workers - 浏览器
Child Process - NodeJS

NodeJs 擅长 I/O 密集型应用的场景

## 模块机制

CommonJS 规范 - 里程碑

### 模块引用

require 方法引入一个模块的 API 到当前的上下文中；

在引入模块的过程中，需要经历如下 3 个步骤：

1. 路径分析；
2. 文件定位；
3. 编译执行；

模块被分为两类：核心模块（Node 提供的） 和 文件模块（用户编写的）；

- 核心模块在 Node 源码编译时就被编译成了二进制，运行时直接加载于内存中，文件定位和编译执行被省略，且在路径分析中优先判断，因此加载速度是最快的；
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位和编译执行的过程，速度比核心模块慢；

### 模块定义

对应引用的功能，上下文提供了 exports 对象用于到处当前模块的方法或变量，并且它是唯一的导出的出口；

在模块中，还存在一个 module 对象，他代表模块自身，而 exports 是 module 的属性；

### 模块标识

模块标识其实就是传递给 require() 方法的参数，必须符合小驼峰命名的字符串，或者以 .、.. 开头的相对路径或者是绝对路径。

意义在于：将类聚的方法和变量等限定爱思有的作用域中，同时支持引入和导出功能以顺畅地链接上下游依赖；

CommonJS 的模块导出和引入的机制使得用户完全不必考虑变量污染。

### 模块的实现

NodeJS 对引入过的模块（编译和执行后的对象）都会进行缓存（`Module._cache`），以减少二次引入时的开销；

无论是核心模块还是文件模块，require() 方法对相同的模块都是缓存优先的，这是第一优先级，核心模块的缓存检查会先于文件模块；

在分析路径模块时，require() 方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以使二次加载时更快；

#### 路径分析

模块路径：NodeJS 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组；

规则如下：

- 当前文件目录下的 node_modules 目录；
- 父目录下的 node_modules 目录；
- 父目录的父目录下的 node_modules 目录；
- 沿路径向上逐级递归，直到根路径下的 node_modules 目录；

#### 文件定位

1. 文件扩展名分析，NodeJS 会按照 .js、.json、.node 的次序依次补足扩展名；
2. 目录分析和包，如果文件扩展名分析之后，没有找到文件却得到了目录，会将目录当做**包**处理，查找 package.json，

#### 模块编译

`.js`：通过 fs 模块同步读取文件后编译执行；
`.node`：这是用 C/C++ 编写的扩展文件，用 `dlopen()` 方法加载最后的编译生成的文件；
`.json`：通过 fs 模块同步读取文件后用 `JSON.parse()` 解析返回结果；

#### 核心模块

文件模块 依赖 核心模块，核心模块 依赖 内建模块；

JavaScript 核心模块主要有两类职责：

1. C/C++ 内建模块的封装层和桥阶层，供文件模块的引用；
2. 纯粹的功能模块，不需要与底层打交道；

## 异步 I/O

### 事件循环

事件循环本身是一个典型的「生产者/消费者模型」；

异步 I/O、网络请求等是事件的生产者，将这些不同类型的事件传递给观察者，而事件循环则从观察者那里取出事件并处理；

I/O 异步事件的底层的非阻塞 I/O 其实是由阻塞 I/O + 线程池模拟的，因此可以看出来，NodeJS 的的底层并非是单线程；

I/O 异步执行主要被分为两个阶段：**提交请求**和**处理结果**；

I/O 异步执行的主要流程是：`文件模块 -> 核心模块 -> 内建模块 -> libnv（桥接层）-> 创建请求对象（保存回调函数、状态和结果） -> 送入线程池 -> CPU 阻塞 I/O 操作、完成 -> 改变请求对象的状态并将结果放入其中 -> 事件循环检测状态（完成） -> 执行回调`；

因此可以推测，异步 I/O 的回调执行有可能与最初的发起事件不在同一个 Tick；

对于 I/O 事件来说，由于需要系统底层参与，因此与 类似 setTimeout 和 process.nextTick 的非 I/O 异步有一定区别；

而对于 setTimeout 和 process.nextTick 这种非 I/O 异步来说，不需要系统底层参与，setTimeout 和 setInterval 属于 timer 观察者，setImmediate 属于 check 观察者，process.nextTick 属于 idle 观察者，**并且有自己的 nextTick 队列，和微任务相同，在每个事件阶段之后执行，但是执行的时机要早于微任务队列**；

在每一次 Tick 检查中，顺序是 timer 观察者 -> idle 观察者 -> I/O 观察者 -> check 观察者；

同时，idle 观察者是以数组的形式存储回调函数的，而 check 观察者是以链表的形式存储的，而处于其中的个体称为「请求对象」（保存回调函数、状态和结果）；

在每次 Tick 的过程中，会保证每次将 idle 观察者中的回调函数执行完，而 check 观察者执行链表中的**一个回调函数**，这么设计的目的在于保证每轮循环能够快速的结束任务，防止 CPU 占用过多而阻塞后续的 I/O 调用的情况；

Node 环境与浏览器环境关于事件循环的区别在于：
Node 环境中微任务是在各个阶段之间执行；
浏览器环境中微任务仅在执行完**一个宏任务**后执行，_主线程也是宏任务_；

## 异步编程

NodeJS 与 浏览器环境均是事件驱动；

### 函数式编程

> 高阶函数：把函数当做参数或者是将函数作为返回值的函数；

NodeJS 事件的处理方式正是基于高阶函数的特性来完成的；

> 偏函数：创建一个调用另外一个部分——参数或者变量已经预置的函数——的函数；

柯里化是典型例子，可以缓存参数；

### 异步编程的优点

“最大特性莫过于基于事件驱动的非阻塞 I/O 模型”；

不论是计算密集型，还是 I/O 密集型，只要计算不影响的异步 I/O 的调度，那就不构成问题；

建议对 CPU 的耗用不要超过 10 ms，或者将大量的计算分解为诸多的小型计算，通过 setImmediate() 进行调度；

### 异步编程的难点

1. 异常处理，对异步方法进行 `try/catch` 操作只能捕获当次事件循环（一个 Tick）内的异常；
2. 函数嵌套过深（回到地狱），这是异步编程的典型问题；
3. 阻塞代码；
4. 多线程编程，`child_process` 是基础 API，`cluster` 模块是更深层次的应用；
5. 异步转同步；

### 异步编程解决方案：

主要解决方案有如下 3 中：

1. 事件发布/订阅模式；
2. Promise / Deffered 模式；
3. 流程控制库；

#### 事件发布/订阅模式

发布/订阅模式本身并无同步和异步调用的问题，但是 NodeJS 中，emit() 调用多半是伴随着事件循环而异步触发的，因此事件发布/订阅广泛应用于异步编程；

1. 利用事件队列解决雪崩问题

高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度；

利用 events 的 once() 方法请所有的请求的回调压入事件队列中，利用其执行一次就会被监视器移除的特点，保证没一个回调都会被执行一次；

## 内存控制

NodeJS 中通过 JavaScript 使用内存是就会发现只能使用部分内存（64 位系统下约为 1.4GB，而在 32 位系统下约为 0.7GB）；

V8 内存采用分代发，分为老生代和新生代；

老生代内存比较大，用于存放存活时间较长或常驻于内存中的活动对象，在机器为数不同的情况下，老生代在 64 位机器上是 1400MB，在 32 位机器上是 700MB；

新生代内存比较小，用于存放存活时间较短的活动对象，由于 Scavenge 算法，新生代内存由两块 reserved_semispace_size 构成；

V8 内存中允许最多 4 个 reserved_semispace_size 存在，而根据机器位数不同，64 位下每个 reserved_semispace_size 的大小为 16MB，32 位下每个 reserved_semispace_size 的大小为 8 MB；

因此 V8 内存在 64 位机器上最多允许 1464MB，而在 32 为机器上最多允许 732MB；

### 新生代垃圾回收：Scavenge 算法和 Cheney 算法

Cheney 算法：采用复制的方式实现垃圾回收的算法，将堆内存一分为二，每一部分的空间成为 semispace，这两个空间只有一处处于使用中（成为 from），另一个闲置（称为 to）；

在执行垃圾回收的时候，首先遍历 from 部分，获取到存活的对象移动到 to 的部分，然后将 from 全部释放掉，之后将 from 和 to 的角色互换即可。

Scavenge 算法是典型的的牺牲空间换时间的算法，它的主要原理也说明了为什么两个 reserved_semispace_size 大小必须保持一致，因为需要互换；

当一个对象经过多次复制仍然存活时，他将会认为是生命周期长的对象，会被移动到老生代堆内存中，这种过程称之为晋升，晋升的时机是在新生代内存 from 空间被检查时，晋升的条件是：

1. 经历过一次 Scavenge 算法的回收；
2. To 空间的内存占比超过限制（To 空间如果已超过 25% 就直接将其对象晋升）；

### 老生代垃圾回收：Mark-Sweep 和 Mark-Compact

Mark-Sweep 算法分为 标记（Mark） 和 清除（Sweep）；

Mark-Sweep 算法在标记阶段遍历老生代堆内存中所有对象，标记活着的对象，在随后的清除阶段那种，清除没有
被标记的对象；

经过上述的过程可以发现，在一次 Sweep 过程中，没有被标记的对象被清除之后，会在堆内存中产生内存碎片，这些碎片无法被再次分配（因为不连续），因此 Mark-Compact 算法在 Mark-Sweep 基础上演变而来；

Mark-Compact 与 Mark-Sweep 的区别在于，在整理的过程中，将处于活状态的对象往一端移动，移动完成后，直接清理掉边界外的内存，而不是在标记完直接清除已死亡的对象；

老生代的堆内存的垃圾回收算法是 Mark-Sweep 和 Mark-Compact 结合使用，仅有在老生代内存空间不足以对新晋升的对象进行分配时才启动 Mark-Compact 垃圾回收机制；

### 增长式标记

需要知道的是，为了避免 JavaScript 应用逻辑与垃圾回收器看到的不一致的问题，垃圾回收的 3 种基本算法都需要将应用逻辑暂停，待垃圾回收执行完毕后再恢复执行应用逻辑，这种行为被称为“全停顿”；

那么新生代的 Scavenge 算法由于速度比较快，它的全停顿影响较小，但是老生代通常配置较大、存货对象较多，造成的停顿会比较可怕，因此引入了一个新的算法 —— 「增量标记」；

增量标记的原理就是将全停顿拆分为许多小步，每完成一小步则让 JavaScript 应用逻辑执行一小会儿

V8 后续还引入了延迟清理与增量时整理。

### 大内存应用

对于操作大文件的场景下，使用 NodeJS 的 stream 原生模块，直接引入即可；

对于 `fs` 模块可以使用 createReadStream() 以及 createWriteStream() 方法用于创建文件的可读流和可写流；

这其中需要了解的是两种方法的使用：

```javascript
var fs = require("fs");
var reader = fs.createReadStream("in.txt");
var writer = fs.createWriteStream("out.txt");

// 第一种
reader.on("data", function (stream) {
  writer.write(stream);
});

reader.on("end", function () {
  writer.end();
});

//  第二种方式更方便，可读流提供了 pipe 管道方法，封装了 data 事件和写入操作
reader.pipe(writer);
```

## 理解 Buffer

### Buffer 的结构

Buffer 是一个像 Array 的对象，但它主要用于操作字节；

Buffer 是 JavaScript 与 C++ 结合的模块，性能部分由 C++ 实现，非性能相关的部分由 JavaScript 实现；

Buffer 所占用的内存不是通过 V8 分配的，属于堆外内存，C++ 层面实现内存的申请；

由于 Buffer 太过常见，因此 Node 在启动时就将它放到了 global 对象上，因此不需要使用 `require()` 即可直接使用；

#### Buffer 对象

Buffer 对象类似于数组，它的元素是 16 进制的两位数，即 0 ~ 255（00 ~ FF）；

Buffer 是伪数组，如果对其下标元素赋值，

- 所赋的值如果小于 0，就需要加上 256 得到 0 至 255 之间的整数
- 所赋的值如果大于 255，就需要减去 256 得到 0 至 255 之间的整数；
- 所赋的值如果为小数，则舍去小数部分，只保留整数部分；

#### Buffer 内存分配

基于 slab 分配机制；

实际上 Node 在分配 Buffer 内存时，是以 8K 为界限区分 Buffer 是大对象还是小对象；

如果是分配小 Buffer 对象的话，则直接创建一个 slab 单元（8K），内部所有 Buffer 对象在作用域内全部被释放，slab 单元才会被释放；一个 slab 单元是允许多个 Buffer 对象同时存在的，如果多个 Buffer 对象所需要的内存大于 8K，则才会继续申请一个新的 slab 单元；

如果是分配大 Buffer 对象的话，将会分配一个 slowBuffer 对象作为 slab 单元，同时这个 slab 单元将会被 Buffer 独占；

### Buffer 的转换

Buffer 对象可以与字符串之间相互转换；

#### 字符串互转 Buffer

字符串 -> Buffer：主要是通过构造函数来完成的

```javascript
new Buffer(str, [encoding]);
```

Buffer -> 字符串：通过 Buffer 对象的 toString() 可以将 Buffer 对象转换为字符串；

```javascript
buf.toString([encoding], [start], [end]);
```

Buffer 不支持的编码类型包括了中国常用的 GBK、GB2313 和 BIG-5 编码；

fs.createReadStream 方法中第二参数是配置，可以指定读取文件时 Buffer 的分配，`{ highWaterMark: [number] }`，highWaterMark 的值越大，读取的速度就越快；

## 网络编程

### HTTP

HTTP 分为请求 request 和 response；

请求具有三层结构：请求行、请求头和请求体；

1. 请求行：请求方法 method，地址 url，请求版本 httpVersion;
2. 请求头：`key: value` 的格式；
3. 请求体：只读流对象；

响应同样具有三层结构：响应行、响应头和响应体；

### WebSocket

在 WebSocket 出现之前，客户端与服务端进行类似于长连接这种通信的方式主要借助 Comet 技术；

所谓 Comet 技术的细节就是采用长轮询或者是 iframe 流；

长轮询的原理就是：

客户端向服务端发起请求，服务端收到请求后不会立即返回数据，而是将请求挂起，比对需要返回的数据是否有更新，如果有更新则响应请求返回数据，如果没有更新则会被一直挂起至一定的时间后再返回；

而客户端在收到服务端的数据后进行处理，只有在处理完服务器返回的数据后，再次发送请求，建立连接；

这种好处在于，借助服务端对请求的挂起，起到了一定的延长请求时间的作用，减少了很多不必要的请求次数，但是同样的，请求挂起也会浪费资源；

## 构建 Web 应用

### Cookie

为静态组件使用不同的域名，一旦 cookie 过多会导致请求头较大，而且大多数的 Cookie 并不是每次都需要的，因此对于静态组件使用不用的域名可以起到一定的优化作用；

这是因为静态组件（文件）来说，其所涉及到的业务定位几乎不关心状态，而且由于域名不同，还可以突破浏览器
下载线程数的限制；
