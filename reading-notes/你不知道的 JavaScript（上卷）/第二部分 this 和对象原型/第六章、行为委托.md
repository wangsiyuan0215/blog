## 第六章 行为委托

JavaScript 中的函数之所以可以使用 `call()`、`apply()`、`bind()` 方法，就是因为函数本身是对象，而函数对象同样拥有原型链并且关联到了 `Function.prototype` 对象，因此所有函数对象都可以通过委托调用这些默认方法；

`Object.setPrototypeOf(obj, prototype)` 将 prototype 原型对象指定到目标对象 obj；

> from MDN:<br />
> 如果对象的 `[[Prototype]]` 被修改成不可扩展(通过 `Object.isExtensible()` 查看)，就会抛出 `TypeError` 异常；<br />
> 如果 `prototype` 参数不是一个对象或者 `null` (例如，数字，字符串，`boolean`，或者 `undefined`)，则什么都不做；<br />
> 否则，该方法将 obj 的 `[[Prototype]]` 修改为新的值。

### 反词法

简洁方法有一个非常小但是非常重要的缺点，思考如下代码：

```javascript
var Foo = {
  bar() {
    /* ... */
  }, // <- 请注意这段代码
  baz: function baz() {
    /* ... */
  },
};
```

去掉语法糖之后的代码如下：

```javascript
var Foo = {
    bar: functon () { /* ... */ },      // <-
    baz: function baz() { /* ... */ }
};
```

可以看到由于函数对象本身没有名称标识符，因此 `bar()` 的缩写形式实际上会变成一个**匿名函数**并赋值给 `bar` 属性；

而匿名函数没有 name ，因此会导致：

1. 调用栈更难追踪；
2. 自我引用更难；
3. 代码更难理解；

而简洁方法没有 1 和 3 的缺点；

简洁方法去掉语法糖之后是匿名函数表达式，通常不会再调用栈中添加 name，但是比较特殊的是，会给对应的函数对象设置一个内部的 name 属性；

同时请注意，匿名和具名函数仅出现在函数表达式中，同时具名函数的 name 对应的对象在函数内部是不可变的（`writable = false`）；

行为委托认为对象之间是兄弟关系、相互委托，而不是父类和子类的关系；

面向对象的设计模式每次想要创建一个对象的时候需要实例化，其实也是 JavaScript 创建对象类似，只不过 JavaScript 可以直接创建一个对象；

传统面向类的语言中父类和子类、子类和实例之间其实都是复制操作，但是在 `[[Prototype]]` 中并没有复制，相反，它们之间只有委托关系；

ES 6 中 class 基本上只有现有 `[[Prototype]]` 委托机制的一种语法糖；

并且在 ES 6 中 class 的 super 并不是动态绑定的，它会在声明时**“静态”**绑定；
