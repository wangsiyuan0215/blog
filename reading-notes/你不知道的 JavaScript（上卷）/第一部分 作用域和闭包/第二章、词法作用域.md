## 第二章 词法作用域

词法作用域就是定义在词法阶段的作用域；

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做 “遮蔽效应”（内部的标识符 “遮蔽” 了外部的标识符）；

请注意，全局变量可以通过对全局对象的属性引用来进行访问，但是如果非全局对象被遮蔽了，那么是无论如何都无法被访问到的；

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定；

词法作用域**只会**查找**一级标识符**，如果代码中引用了 `foo.bar.baz` 词法作用域只会试图查找 `foo` 标识符，找到之后对象的属性访问规则会接管对 `bar` 和 `baz` 属性的访问；

```javascript
/*    */ foo.bar.baz;
//        |---|---|---> 词法作用域查找规则
//            |---|--------> 对象的属性访问规则
//                |------------> 对象的属性访问规则
```

### with

`with` 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身；

`with` 可以将一个没有或者多个属性的对象处理为一个完全隔离的词法作用域，因此对这个对象的属性也会被处理为定义在这个作用域中的词法标识符；

`with`、函数作用域和全局作用域中如果没有找到某个标识符 `a`，因此当执行 `a = 2` 赋值表达式时，自动创建了一个全局变量 `window.a`（在非严格模式下）；

### 动态作用域

由词法作用域可知，词法作用域是静态作用域，是由书写时确定的；

那么动态作用域就是由执行时(runtime)阶段确定的；

本身 JS 没有动态作用域，但是 this 机制从某种程度上来说，是很像动态作用域的；

需要分清楚的是，作用域链和作用域嵌套；

在 JS 中，作用域链是在 runtime 时确定的，是由调用栈确定的；而作用域嵌套时书写时（编译阶段）确定的；
